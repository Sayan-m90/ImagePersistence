//
//  main.cpp
//  BitTests
//
//  Created by Bill Varcho on 2/24/16.
//  Copyright Â© 2016 Bill Varcho. All rights reserved.
//
/*
*/
#include "Collapse.hpp"
#include "Constants.hpp"
#include "GIC.hpp"
#include "Wrappers/GICWrapper.hpp"
#include "Graphs/KNN_Graph.hpp"
#include "Graphs/NormalGraph.hpp"
#include "MortonCode.hpp"
#include "RandomHomology.hpp"
#include "Wrappers/SimPersWrapper.hpp"
#include "Utilities.hpp"
#include <dirent.h>
#include <time.h>
#include <iostream>
#include <vector>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/filesystem.hpp>
#include <boost/thread.hpp>
#include <string>
#include <cstdio>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <cv.h>
#include <highgui.h>
using std::cout;
using std::endl;
using std::string;
//using std::priority_queue;
#define PI 3.14159265
using std::vector;
using namespace cv;
/***********************************************/
string strLicense = "THIS SOFTWARE IS PROVIDED \"AS-IS\". THERE IS NO WARRANTY OF ANY KIND. "
"NEITHER THE AUTHORS NOR THE OHIO STATE UNIVERSITY WILL BE LIABLE FOR "
"ANY DAMAGES OF ANY KIND, EVEN IF ADVISED OF SUCH POSSIBILITY. \n"
"\n"
// "This software was developed (and is copyrighted by) the Jyamiti group at "
// "The Ohio State University. Please do not redistribute this software. "
"This program is for academic research use only. This software uses the "
"Boost library (www.boost.org) "
"which is covered under their own licenses.\n"
"\n"
"The Boost library's license "
"(which applies to the Boost library ONLY and NOT to this program itself) is "
"as follows:\n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"Boost Software License - Version 1.0 - August 17th, 2003\n"
"\n"
"Permission is hereby granted, free of charge, to any person or organization "
"obtaining a copy of the software and accompanying documentation covered by "
"this license (the \"Software\") to use, reproduce, display, distribute, "
"execute, and transmit the Software, and to prepare derivative works of the "
"Software, and to permit third-parties to whom the Software is furnished to "
"do so, all subject to the following: \n"
"\n"
"The copyright notices in the Software and this entire statement, including "
"the above license grant, this restriction and the following disclaimer, "
"must be included in all copies of the Software, in whole or in part, and "
"all derivative works of the Software, unless such copies or derivative "
"works are solely in the form of machine-executable object code generated by "
"a source language processor. \n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR "
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, "
"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT "
"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE "
"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, "
"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER "
"DEALINGS IN THE SOFTWARE. \n"
"---------------------------------------------------------------------------\n";
/**********************************************************************/

// TODO: set default values
bool ParseCommand(int argc, char* argv[], string &input_points_file, string &output_stat_file, int &neighbors, float &subsample, int &finalvec, int &label)
{
	try
	{
		// Define the program options description
		namespace po = boost::program_options;
		po::options_description desc("Software Usage");
		desc.add_options()
			(",h", "Help information;")
			(",l", "License information;")
			(",n", po::value<int>(&neighbors)->default_value(17), "The number of nearest neighbours to create the intial graph. Default 12")
			(",i", po::value<std::string>(&input_points_file)->default_value(""), "The image input")
			(",o", po::value<std::string>(&output_stat_file)->default_value("stat.csv"), "The output file name")
			(",s", po::value<float>(&subsample)->default_value(5), "The subsample ratio to choose in subsequent collapse operations. Chooses every sth datapoint in the Octree ordering")
			(",v", po::value<int>(&finalvec)->default_value(10), "The number of persistence barcodes to keep in final vector. Default 10")
			(",b", po::value<int>(&label)->default_value(-1), "The label of the image. None assigned if not passed.");
		// Parser map
		po::variables_map vm;
		try
		{
			po::store(po::parse_command_line(argc, argv, desc), vm);

			//
			if (vm.count("-h"))
			{
				cout << desc << std::endl;
				exit(EXIT_SUCCESS);
			}
			//
			if (vm.count("-l"))
			{
				cout << strLicense << std::endl;
				exit(EXIT_SUCCESS);
			}

			po::notify(vm);
		}
		catch (boost::program_options::required_option& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
		catch (boost::program_options::error& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
	}
	catch (std::exception& e)
	{
		std::cerr << "Unhandled Exception reached the top of main: "
			<< e.what() << ", application will now exit" << std::endl;
		return false;

	}
	return true;
}

void imagetoMatconv(Mat img, string filename)
{
	int h = img.size().height;
	int w = img.size().width; 
	float blue[h][w] = {0};
	float green[h][w] = {0};
	float red[h][w] = {0};
	float meanr = 0;
	float meang = 0;
	float meanb = 0;
	Scalar mean, stddev;
	meanStdDev(img,mean,stddev,cv::Mat());
	// cout<<stddev.val[0]<<"\t"<<mean.val[0]<<"\t"<<mean.val[1]<<"\t"<<mean.val[2];
	ofstream myfile;
	myfile.open(filename);
	
	for(int x=0;x<w;x++)
	{
		for(int y=0;y<h;y++)
		{
			Vec3b intensity = img.at<Vec3b>(y, x);
			blue[y][x] = (intensity.val[0]-mean.val[0])/stddev.val[0];
			green[y][x] = (intensity.val[1]-mean.val[1])/stddev.val[1];
			red[y][x] = (intensity.val[2]-mean.val[2])/stddev.val[2];

			myfile<<red[y][x]<<" "<<green[y][x]<<" "<<blue[y][x]<<" "<<x<<" "<<y<<"\n";
		}
	}

	myfile.close();

}

void extracthighesbar(string input, string output, int num, int label)
{
	
	ifstream infile;
	ofstream outfiletxt;

	bool outputflag ;

	outfiletxt.open(output,std::fstream::app);
	
		infile.open(input);
		int max[num] = {};
		
		int birthmax[num] = {};
		int deathmax[num] = {};
		outputflag = false;
		string dim, birth, death;
		while (!infile.eof( ))
	 	{
	 		infile>>dim>>birth>>death;
	 		
	 		if(dim.compare("1")==0)
	 		{
	 			int lives = atoi(death.c_str()) - atoi(birth.c_str());
	
	 			for(int j=0;j<num;j++)
	 				{

	 					if(max[j]<lives)
	 					{
	 						for(int k=num-1;k>j;k--)
	 						{
	 							max[k] = max[k-1];
	 							birthmax[k] = birthmax[k-1];
	 							deathmax[k] = deathmax[k-1];
	 						}
	 					max[j] = lives;
	 					birthmax[j] = atoi(birth.c_str());
	 					deathmax[j] = atoi(death.c_str());
	 					break;
	 					}
	 				}

	 		} 		
	 		else if(dim.compare("2")==0) break;
	 		else continue;


	 	}
	 	
for(int j=0;j<num;j++)
	outfiletxt<<deathmax[j]-birthmax[j]<<",";

if(label == -11)
	outfiletxt<<"\n";
else
	outfiletxt<<label<<","<<"\n";
	infile.close();
 	outfiletxt.close();
 	
}

int main(int argc,  char * argv[]) 
{

	    

    string input_points_file,output_stat_file;       // = "/Users/billvarcho/Documents/models/kitten.txt";
    int max_dim=2, neighbors=20, finalvec=10, label=-1;
    float subsample=17;


    ParseCommand(argc, argv, input_points_file, output_stat_file, neighbors, subsample, finalvec, label);

	Mat image = imread(input_points_file,1);
	vector<string> dir_strings;
	boost::split(dir_strings, input_points_file, boost::is_any_of("."));
	string points_name = dir_strings[0];
	input_points_file = points_name+".txt";
	imagetoMatconv(image,input_points_file);	


    string complex_file =  points_name + "_complex.txt";
    string output_collapses = points_name;


    if(max_dim<1)
    	{cout<<"Maximum Dimension of persistent barcode needs to be greater than 1: FAILED";	return 0;}
    if(subsample<2)
    	{cout<<"Subsampling jump chosen for the subsequent collapse operations need to be greater than 2: FAILED";	return 0;}
    

    cout<<"\ngetting into GIC ss:"<<subsample<<" max_dim: "<<max_dim<<" neighbors: ";

    const clock_t begin_time = clock();
    GICWrapper::Run(input_points_file, complex_file, max_dim, neighbors);
    


    GIC g(complex_file);
    fflush(stdin);
    cout<<"Out of GIC\n";

    vector<Operation*> collapses;
    RandomHomology r(g);
    r.run(subsample, collapses);
    cout << "\nCollapse with GIC Total Timing without I/O:" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;
    Utilities::WriteCollapsesToFile(output_collapses, collapses);
    cout << "\nCollapse with GIC Total Timing :" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;

    SimpersWrapper::Run( collapses, output_collapses);
    cout << "\n\nTotal Running Time:" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;
    extracthighesbar((points_name+"_pers"), output_stat_file, finalvec, label);

    string input_image_folder = points_name+"_collapses";
    remove(input_image_folder.c_str());

    input_image_folder = points_name+".txt";
    remove(input_image_folder.c_str());

    input_image_folder = complex_file;
    remove(input_image_folder.c_str());
    input_image_folder = points_name+"_iDC";
    remove(input_image_folder.c_str());
    input_image_folder = points_name+"_range";
    remove(input_image_folder.c_str());
    input_image_folder = points_name+"_pers";
    remove(input_image_folder.c_str());
}
